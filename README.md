# Документация для разработчиков: Subscription Service

## Общая архитектура

Приложение реализовано на **Spring Boot** и построено по принципу слоистой архитектуры:

- **Контроллеры** (`controller`) — принимают HTTP-запросы, валидируют входные данные, вызывают бизнес-логику.
- **Сервисы** (`service`) — содержат бизнес-логику, работают с репозиториями.
- **Репозитории** (`repository`) — интерфейсы для доступа к данным через Spring Data JPA.
- **Сущности** (`entity`) — отображают таблицы базы данных.

В качестве базы данных используется **PostgreSQL**. Приложение запускается в Docker-контейнере.

---

## Основные сущности

### User

- **Описание:** Пользователь системы.
- **Поля:**
    - `id` — идентификатор (Long, autogenerated)
    - `name` — имя пользователя (String)
    - `email` — email пользователя (String, уникальный)
- **Связи:** Один пользователь может иметь несколько подписок (`subscriptions`).

### Subscription

- **Описание:** Подписка пользователя на сервис.
- **Поля:**
    - `id` — идентификатор (Long, autogenerated)
    - `serviceName` — название сервиса (String)
    - `user` — ссылка на пользователя (ManyToOne)
- **Связи:** Каждая подписка принадлежит одному пользователю.

---

## Слой репозиториев

Используются интерфейсы, расширяющие `JpaRepository`:

- `UserRepository` — для работы с пользователями.
- `SubscriptionRepository` — для работы с подписками.

Spring Data JPA автоматически реализует стандартные методы (поиск, сохранение, удаление и т.д.).

---

## Слой сервисов

### UserService

- **Задачи:**
    - Создание, получение, обновление, удаление пользователей.
    - Добавление и удаление подписок пользователю.
    - Получение подписок пользователя.

### SubscriptionService

- **Задачи:**
    - Получение топ-3 самых популярных подписок (по количеству пользователей).
    - Вспомогательные методы для работы с подписками.

---

## Слой контроллеров

### UserController

- **Маршруты:**
    - `POST /users` — создать пользователя.
    - `GET /users/{id}` — получить пользователя по id.
    - `PUT /users/{id}` — обновить пользователя.
    - `DELETE /users/{id}` — удалить пользователя.
    - `POST /users/{userId}/subscriptions` — добавить подписку пользователю.
    - `GET /users/{userId}/subscriptions` — получить все подписки пользователя.
    - `DELETE /users/{userId}/subscriptions/{subscriptionId}` — удалить подписку пользователя.

### SubscriptionController

- **Маршруты:**
    - `GET /subscriptions/top` — получить топ-3 популярных подписок.

---

## DTO (Data Transfer Objects)

Для передачи данных между слоями и наружу используются DTO-классы, чтобы не раскрывать внутреннюю структуру сущностей.

---

## Валидация

- Используются аннотации валидации (`@NotNull`, `@Email`, и т.д.) для DTO и сущностей.
- Ошибки валидации автоматически обрабатываются Spring Boot.

---

## Исключения и обработка ошибок

- Для обработки ошибок используются кастомные исключения и глобальный обработчик (`@ControllerAdvice`).
- Возвращаются информативные сообщения об ошибках с соответствующими HTTP-статусами.

---

## Расширяемость

- Для добавления новых типов подписок или дополнительных полей в сущностях достаточно расширить соответствующие классы и обновить миграции БД.
- Для новых бизнес-фич добавляйте методы в сервисы и контроллеры, не нарушая принцип единой ответственности.

---

## Пример типового workflow

1. **Создание пользователя:**  
   Клиент отправляет POST-запрос на `/users` с JSON-данными. Контроллер валидирует данные, вызывает сервис, который сохраняет пользователя через репозиторий.

2. **Добавление подписки:**  
   POST-запрос на `/users/{userId}/subscriptions` с названием сервиса. Контроллер вызывает сервис, который создает подписку и связывает с пользователем.

3. **Получение топ-3 подписок:**  
   GET-запрос на `/subscriptions/top`. Сервис агрегирует данные по количеству пользователей на каждый сервис и возвращает топ-3.
